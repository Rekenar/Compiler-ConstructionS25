### Task 5 Jump Labels
The following Java code snippet uses Code and Label classes of the MJ.CodeGen package of the MicroJava compiler to generate code for an if-else statement. x, y, and z are operand descriptors referring to local variables at addresses 0, 1, and 2, respectively.

Label elseLabel = new Label();
Label endLabel = new Label();

Code.load(x); Code.load(y);
Code.put(Code.jge); elseLabel.putAdr();
Code.load(x); Code.assignTo(z);
Code.put(Code.jmp); endLabel.putAdr();
elseLabel.here();
Code.load(y); Code.assignTo(z);
endLabel.here();

Determine the MJVM instructions generated by this code snippet, assuming that the first generated instruction is located at code address 100. For each MJVM instruction, represent its code address, instruction including explicit operands, and instruction length (in bytes). Moreover, explain when the final jump target addresses are written to the code buffer during execution of the given Java code
snippet.

if (x >= y)
   z = x;
else
   z = y;


1) Code.load(x) where x is local @ address 0

If x.kind == Local and x.adr == 0, then:
Code.put(Code.load0); // 1 byte
[100] load0         (1 byte)

2) Code.load(y) where y is local @ address 1

Code.put(Code.load1); // 1 byte
[101] load1         (1 byte)

3) Code.put(Code.jge); elseLabel.putAdr();
Slide 24 and 67

jge is a conditional jump, 1 byte opcode + 2 byte offset

Address of jump target is not known yet, so putAdr() emits a placeholder 0 and remembers the fixup

Code.put(Code.jge);         // 1 byte
elseLabel.putAdr();         // writes 2-byte 0, stores fixup

[102] jge             (1 byte)
[103] 00 00           (2 bytes placeholder)
elseLabel is undefined, and fixup address 103 is remembered.

4) Code.load(x); Code.assignTo(z);

load(x) → load0 (again) → 1 byte
assignTo(z) → store2 (because z.adr == 2) → 1 byte

[105] load0           (1 byte)
[106] store2          (1 byte)

5) Code.put(Code.jmp); endLabel.putAdr();

Unconditional jump to an unknown address (forward jump).

jmp → 1 byte
putAdr() → 2 bytes placeholder 00 00 + stores fixup

[107] jmp             (1 byte)
[108] 00 00           (2 bytes placeholder)
endLabel is undefined, fixup at 108 is remembered.

6) elseLabel.here();

Now we define the label. At this point, Code.pc = 110
elseLabel.here(); // fills in offset at 103

@103: offset = 110 - (103 - 1) = 110 - 102 = 8 → write 00 08

Patched instruction at 103 becomes:
[103] 00 08           (2 bytes → jump 8 forward)

7) Code.load(y); Code.assignTo(z);
Same logic as before:

load1 → 1 byte
store2 → 1 byte

[110] load1           (1 byte)
[111] store2          (1 byte)

8) endLabel.here();
Now Code.pc = 112 → define label → patch fixup at 108:

@108: offset = 112 - (108 - 1) = 112 - 107 = 5 → write 00 05

Patched instruction at 108 becomes:
[108] 00 05           (2 bytes → jump 5 forward)


Final MJVM Table:
| Addr | Instruction | Meaning              | Size |
| ---- | ----------- | -------------------- | ---- |
| 100  | `load0`     | load x               | 1    |
| 101  | `load1`     | load y               | 1    |
| 102  | `jge 8`     | conditional jump     | 1    |
| 105  | `load0`     | load x               | 1    |
| 106  | `store2`    | store to z           | 1    |
| 107  | `jmp 5`     | unconditional jump   | 1    |
| 110  | `load1`     | load y               | 1    |
| 111  | `store2`    | store to z           | 1    |
| 112

Total Length: 12 bytes
Final value of Code.pc: 112

| Addr | Instruction | Semantic Action      | Slide |
| ---- | ----------- | -------------------- | ----- |
| 100  | `load0`     | `Code.load(x)`       | 38    |
| 101  | `load1`     | `Code.load(y)`       | 38    |
| 102  | `jge`       | `Code.put(Code.jge)` | 67    |
| 103  | `00 08`     | `elseLabel.putAdr()` | 62    |
| 105  | `load0`     | `Code.load(x)`       | 38    |
| 106  | `store2`    | `Code.assignTo(z)`   | 56    |
| 107  | `jmp`       | `Code.put(Code.jmp)` | 58    |
| 108  | `00 05`     | `endLabel.putAdr()`  | 62    |
| 110  | `load1`     | `Code.load(y)`       | 38    |
| 111  | `store2`    | `Code.assignTo(z)`   | 56    |

Label mechanism described in Slides 61–63.
| Label     | Fixup At | Resolved At | Offset Written | Formula           |
| --------- | -------- | ----------- | -------------- | ----------------- |
| elseLabel | 103      | 110         | `08`           | `110 - (103 - 1)` |
| endLabel  | 108      | 112         | `05`           | `112 - (108 - 1)` |

